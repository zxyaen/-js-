<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]>      <html class="no-js"> <!--<![endif]-->
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title></title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="">
</head>

<body>
    <p>
        给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

        你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

        你可以按任意顺序返回答案。
    </p>

    <script>
        //解1:暴力遍历
        //时间复杂度 O(n^2)
        // let num = [2, 4, 3, 7, 9, 5]
        // function sum(nums, target) {
        //     console.log(nums, target);
        //     for (let i = 0; i < nums.length; i++) {
        //         for (let j = i + 1; j < nums.length; j++) {
        //             if (nums[i] + nums[j] === target) {
        //                 console.log(i, j);
        //                 return
        //             }
        //         }
        //     }
        // }
        // sum([2, 4, 5, 7, 5, 7], 14)

        //解2:利用Map，map中不含target-当前值的数，则将当前值加入map中，遍历
        //时间复杂度O(n)
        let num = [2, 4, 3, 7, 9, 5]
        function sum(nums, target) {
            const map = new Map()

            for (let i = 0; i < nums.length; i++) {
                let x =target-nums[i]  
                //若数组中存在符合target-nums[i]的值，利用get获取到该值的索引，并返回索引以及当前i
                if(map.has(x)){
                    return [map.get(x),i]
                }
                map.set(nums[i], i);
                //map([2,0],)[2,0]
                //map([2,0],[3,2],)
            }
            //若没有符合条件target，则返回空数组
           return []
        }
        let a = sum(num,14)
        console.log(a);
    </script>
</body>

</html>